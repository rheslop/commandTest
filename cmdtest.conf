
# Directories to be used by script
#
CMD_HISTORY=~/.cmdTest/history
CMD_STACKS=~/.cmdTest/stacks


# COMMANDS USED BY SCRIPT
#
README=/opt/cmdTest/README
STACKMANAGER=/opt/cmdTest/stackManager

# Make directories to be used by script

[[ -d $CMD_HISTORY ]] || mkdir -p $CMD_HISTORY
[[ -d $CMD_STACKS ]] || mkdir -p $CMD_STACKS

# numQuestionsAsked is the Total number of questions the user requests to be asked
numQuestionsAsked=0

# numRand is a random number between 1 and $numQuestions
numRand=0
# prevQuestion ensures this question isn't the same as the last
prevQuestion=0

finalScore=0

# Start time date
STARTD=$(date +%Y.%m.%d)
STARTT=$(date +%T)


# Check the current status of the stack.
# There should be a single file if a stack is loaded.
# If 1 is returned, a single file is found.					STACKERR=0
# If nothing is returned, there is nothing found in the directory.		STACKERR=1
# If anything else is returned, there are too many files.			STACKERR=2
# In most instances, the script WILL NOT be tested under a STACKERR=2 condition,
# so it will be best to not run at all.  This status should be checked in other
# scripts before execution proceeds.

CHECKED_STACK=$( ls $CMD_STACKS | sort | cut -d. -f1 | uniq -d )
STACKCHECK=$( echo "$CHECKED_STACK" | nl | awk 'END{print $1}' )
case $STACKCHECK in
	1)
	STACKERR=0
	;;
	"")
	STACKERR=1
	;;
	*)
	STACKERR=2
	;;
esac

# Grab the total number of questions

if [ $STACKERR -eq "0" ]; then
numQuestionsTotal=$( sqlite3 $CMD_STACKS/${CHECKED_STACK}.db "SELECT COUNT(*) FROM main;" )
fi

if [ -z "$numQuestionsTotal" ]; then
	numQuestionsTotal=0
fi

##### Functions #####

# If more than one stack appears checked out - clear

function CLEAR_CHECKOUT {
for i in $(ls $CMD_STACKS); do 
	if [[ $(echo $i | awk -F. '{print NF}') == 1 ]]; then
		rm $CMD_STACKS/$i
	fi
done
}

# Check out stack

function CHECKOUT_STACK {
if [ -z $1 ]; then
	echo "No response received."
	sleep 1
else
	if [ -e $CMD_STACKS/$1* ]; then
		CLEAR_CHECKOUT
		touch $CMD_STACKS/$1
		. /opt/cmdTest/cmdtest.conf
	else
		echo -e "Invalid option \"$1\"!"
		sleep 1
	fi
fi
}

# List stacks

function LIST_STACKS {
stackIndex=0
for i in $( ls $CMD_STACKS | cut -d. -f1 | sort | uniq ); do 
	stackList[$stackIndex]=$(echo "$i" | awk -F. '{print $1}')
	((stackIndex++))
done
echo ${stackList[@]}
}

# stack option two = create a stack

function CREATE_STACK {
STACKNAME=$1
cat /dev/null > $CMD_STACKS/${STACKNAME}.db
sqlite3 $CMD_STACKS/${STACKNAME}.db "CREATE TABLE main (id INTEGER PRIMARY KEY, Question TEXT, Answer TEXT);"
}

# View all questions in checked stack

function VIEW {
. /opt/cmdTest/cmdtest.conf
for i in $(seq 1 $numQuestionsTotal); do
echo "${i}. -------------"
echo -n "Question: "
sqlite3 $CMD_STACKS/${CHECKED_STACK}.db "SELECT Question from main WHERE id = $i;"
echo""
echo -n "Answer: "
sqlite3 $CMD_STACKS/${CHECKED_STACK}.db "SELECT Answer from main WHERE id = $i;"
echo ""
done
}

# For finding question in sqlite database based on query

function FINDQ {
. /opt/cmdTest/cmdtest.conf
read -p "Search > " SEARCHTERM
echo ""
echo "Searching checked stack: $CHECKED_STACK"
CONTAINS=$( sqlite3 $CMD_STACKS/${CHECKED_STACK}.db 'SELECT * FROM main;' )
SEARCH_RESULTS=$( echo "$CONTAINS" | grep "$SEARCHTERM" )

if [ -z "$SEARCH_RESULTS" ]; then 
	echo "\"$SEARCHTERM\" not found."
else
	echo $SEARCH_RESULTS
fi

echo ""
echo ""
echo "Press [enter] to continue"
read

}

function GETINFO {
. /opt/cmdTest/cmdtest.conf
clear
echo "=============================="
echo ""
echo -e "* History files are saved in \E[0;36m${CMD_HISTORY}.\E[0;m"
echo ""
if [ "$STACKERR" -eq 2 ]; then
        echo -e "\e[0;31m* ERROR: There appears to have been a problem in \"${CMD_STACKS}\".  Clearing stack."
        CLEAR_CHECKOUT
        else
        echo -e "* Current Stack: \"\E[0;36m$CHECKED_STACK\E[0;m\" with \E[0;36m$numQuestionsTotal\E[0;m questions."
fi
echo ""
echo -e "* Your stacks are kept in Directory \E[0;36m${CMD_STACKS}\E[0;m."
echo -e -n "File Listing: \E[0;36m"
ls $CMD_STACKS
echo -e "\e[0m"
echo "=============================="
echo ""
echo "Press <enter> to return"
read
}

function POPULATE {
. /opt/cmdTest/cmdtest.conf

if [[ $STACKERR == 0 ]]; then 
	read -r -p "Question ~> " QUESTION
	read -r -p "Answer ~> " ANSWER
	echo ""
	echo -n "Question: "
	echo $QUESTION
	echo ""
	echo -n "Answer: "
	echo $ANSWER
	echo ""
	echo "Confirm keep? [y|n]"
	read -p "~> " KEEP
	case $KEEP in
        	y|Y)
		# sqlite hates single quotes
		ANSWER_SANITIZED=$( echo $ANSWER | sed s:\':\'\':g )
		QUESTION_SANITIZED=$( echo $QUESTION | sed s:\':\'\':g )
        	sqlite3 $CMD_STACKS/${CHECKED_STACK}.db "INSERT INTO main (Question, Answer) VALUES ('$QUESTION_SANITIZED','$ANSWER_SANITIZED');"
        	;;
        	n|N)
		unset QUESTION
		unset ANSWER
        	echo "Question discarded."
        	;;
        	*)
        	echo -e "\E[31m$KEEP is not a valid response. Use 'y' or 'n'\E[0m"
        	confirm
        	;;
	esac
	echo ""
	echo "Another? [y|n]"
	read -r -p "~> " ANOTHER
	case $ANOTHER in
		y|Y)
		POPULATE
		;;
		n|N)
		echo -n "exiting"
		sleep .25; echo -n "."; sleep .25; echo -n "."; sleep .25; echo -n ".";
		;;
		*)
		echo -e "\E[31m\"$ANOTHER\" is not a valid option.  Exiting to be safe.\E[0m"
		sleep 1
		;;
	esac
else
	CLEAR_CHECKOUT
	echo -e "\e[31;mCannot load test. Please check a stack out.\e[0;m"
	sleep 1
fi
}

# Check STACKERR before testing

function TEST {
. /opt/cmdTest/cmdtest.conf
if [ "$STACKERR" -eq 0 ]; then
	if [ "$numQuestionsTotal" -eq 0 ]; then
		echo -e "\E[0;31mI don't see any questions populated in stack \"$CHECKED_STACK\""
		echo -e "Cannot load test.\E[0m"
		sleep 1
		/opt/cmdTest/cmdtest.sh
	else
	CMDTEST
	fi
else
	echo -e "\e[31;mCannot load test. Please check a stack out.\e[0;m"
	echo ""
	echo -n "Which stack would you like to check out?:"
	LIST_STACKS
	echo ""
	read -p "~> " STACK_REQ
	CHECKOUT_STACK $STACK_REQ
	echo -e -n "Starting test \"$STACK_REQ\""
	sleep .5
	echo -n "."
	sleep .5
	echo -n "."
	sleep .5
	echo -n "."
	CMDTEST
fi
}

function MATCH_PREV_QUESTIONS {
        local MINI_STACK=${1}[@]
        local CARD=${2}

        for c in ${!MINI_STACK}; do
                if [[ ${c} == ${CARD} ]]; then
                        return 0
                fi
        done
        return 1
}

function CMDTEST {
. /opt/cmdTest/cmdtest.conf

if [  "$numQuestionsTotal" -lt 5 ]; then
        CARDBUFFER_LENGTH=1
elif [  "$numQuestionsTotal" -lt 10 ]; then
        CARDBUFFER_LENGTH=3
elif [  "$numQuestionsTotal" -lt 15 ]; then
        CARDBUFFER_LENGTH=5
else CARDBUFFER_LENGTH=10
fi

declare -a CARDBUFFER
CARDBUFFER+='0'

challenge(){
clear


MATCH_PREV_QUESTIONS CARDBUFFER $numRand
MATCH_SUCCESS=$?

while [ "$MATCH_SUCCESS" -eq 0 ]; do
	numRand=$[ 1 + $[ RANDOM % $numQuestionsTotal ]]
	MATCH_PREV_QUESTIONS CARDBUFFER $numRand
	MATCH_SUCCESS=$?
done

if [ "$CARDBUFFER_LENGTH" -le "${#CARDBUFFER[@]}" ]; then
        CARDBUFFER=("${CARDBUFFER[@]:1}")
fi

# First print running score
# Figure out the present question, and minus 1
j=$(( $i - 1))

# Avoid divide by zero, don't set variable until we're at at least one

if [ $j -gt 0 ]; then
	RUNNING_SCORE=$(echo "scale=2; $finalScore/$j" | bc)
fi

echo -n -e "\E[37;40mTotal ${numQuestionsAsked} | Correct ${finalScore} | Answered ${j} "

if [ -z $RUNNING_SCORE ]; then
	echo -e "\E[0m"
else
	echo -e "| Score \E[0;36;40m$RUNNING_SCORE\E[0m"
fi

#echo -n -e "\E[37;40m | BUFFER = ${CARDBUFFER[@]}"
#echo -e " \E[0;36;40m$numRand\E[0m"
echo ""
CARDBUFFER+=($numRand)
echo "Question $i."
echo "-------------"

# It's better to pull the table into memory ($TEMP) than referencing directly
# This way we can guaranty sequential questions and answers in case some have
# been removed.

TEMP=$( sqlite3 $CMD_STACKS/${CHECKED_STACK}.db "SELECT * FROM main;" )
ANSWER=$( echo "$TEMP" | awk -F\| 'NR=='$numRand' {print $3}' )

# Print question
echo "$TEMP" | awk -F \| 'NR=='$numRand' {print $2}'
echo ""
echo ""
read -p "Answer ~> " RESPONSE
if [ "$RESPONSE" = "$ANSWER" ]; then
	score=1
else
	score=0
fi

}

clear

# Because the test will not present the same question twice
# in a row, if you have only one question populated in your
# stack, you are not given the option to select the number
# of questions in a given test - it is kept at 1.

if [ "$numQuestionsTotal" -eq 1 ]; then
	numQuestionsAsked=1
else
	echo ""
	echo "How many questions would you like to take?"
	echo ""
	read -p "# ~> " numQuestionsAsked
fi

# Make sure the number of questions requested is a number
re='^[0-9]+$'
if [[ "$numQuestionsAsked" =~ $re ]]; then
	for (( i=1; i<=$numQuestionsAsked; i++ ))
		do
		challenge
		if [ $score == 1 ];
			then finalScore=`expr $finalScore + 1`;
			echo -e "\E[0;32mCorrect !\E[0;m"
			echo ""
			sleep 1
		else
			clear

			# Print question
			echo "$TEMP" | awk -F \| 'NR=='$numRand' {print $2}'

			# If no answer is given, then no need to echo answer back to user
			if [ -z "$RESPONSE" ]; then
				echo "The correct answer is: \"$ANSWER\""
			else
				echo "\"$RESPONSE\" is incorrect.  The correct answer is: \"$ANSWER\""
			fi

			echo ""
			# Will need additional actions for explanation field
			echo "Press <enter> to continue:"
			read
		fi
	done
	
	unset RUNNING_SCORE

        # Grade test

	perSCORE=$(echo "scale=2; $finalScore/$numQuestionsAsked" | bc)
	HIST_DATA_FILE=${CMD_HISTORY}/${CHECKED_STACK}_HISTORY.db

	if [ ! -f "$HIST_DATA_FILE" ]; then
		cat /dev/null > $HIST_DATA_FILE
        	sqlite3 $HIST_DATA_FILE "CREATE TABLE main (id INTEGER PRIMARY KEY, Date TEXT, Start TEXT, End TEXT, QinStack INTEGER, Correct INTEGER, Asked INTEGER, Percent, TEXT );"

	fi

	ENDT=$(date +%T)
	TEST_DATE=$( date +%F)

	sqlite3 $HIST_DATA_FILE "INSERT INTO main (Date, Start, End, QinStack, Correct, Asked, Percent) VALUES ('$TEST_DATE','$STARTT','$ENDT','$numQuestionsTotal','$finalScore','$numQuestionsAsked','$perSCORE' );"

else
	echo -e "\E[0;31mOops!  \"$numQuestionsAsked\" confuses me.  Did you mean to exit?"
	sleep 1	

fi
}

function GET_HISTORY {

HIST_TEMP=$( sqlite3 ${CMD_HISTORY}/${CHECKED_STACK}_HISTORY.db "SELECT * FROM main;" )
HIST_TEMP_RECENT=$(echo "$HIST_TEMP" | tail -n 8 )
HIST_COUNT=$( echo "$HIST_TEMP_RECENT" | wc -l )
echo ""
for i in $(seq 1 $HIST_COUNT);
	do
echo "$HIST_TEMP_RECENT" | awk -F \| 'NR=='$i' {print $2}'
echo "--------------------" 
echo -n "Questions:"
echo -ne "\t"
echo "$HIST_TEMP_RECENT" | awk -F \| 'NR=='$i' {print $7}'
echo -n "Correct:"
echo -ne "\t"
echo "$HIST_TEMP_RECENT" | awk -F \| 'NR=='$i' {print $6}'
echo -n "Score:"
echo -ne "\t\t"
echo "$HIST_TEMP_RECENT" | awk -F \| 'NR=='$i' {print $8}'
echo "--------------------"
echo ""
done
echo "Bottom is most recent."
echo "Press <enter> to continue:"
read
}
